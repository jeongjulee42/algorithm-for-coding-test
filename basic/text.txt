0 12345
1 21000
2 00430
3 03200
4 00000
5 21054
6 00000

tc
5 5 6
1 1
3 2
2 3
5 1
5 4

//입력
    //추가해야하는 가로선 개수의 최솟값. 3보다 크다면 -1 출력, 불가능하면 -1출력
    // -> 선추가 0개, 1개, 2개 -> 전부안되면 -1 출력.
    // a b -> b와 b+1을 a가로선에서 연결.

//전체 로직
//1.입력받아서 해당 배열 만들기
//1-1 세로선 n, 들어올 선 개수 m, 가로선 h 입력받기
//  배열만들기. n+1, h+1 개 배열 만들어야함.
//1-2 for문으로 m개만큼 선 입력받기
//      a, b 입력받기. -> ary[a][b] = b+1; ary[a][b+1] = b;
// cnt = 0;

//2.선 추가 0개이므로 i번째가 i로 가는지 확인.
    // if(cnt >= 3) ret = -1; break;
    // check();
    // cnt++;
    //      bool check() 함수 구축. 
    //      for문 1~5까지 돌면서 각 번호 체크. for문 중간에 i가 i로 안가면 break;
    //      전부 다 가면 flag = 1; 로 바꾸고 ret = cnt;
    //      for(int i = 1; i <= n; i++){
    //          현재 위치에서 가로선 있는지 확인
    //          있다면 이동하고 한칸 밑으로
    //          없다면 그냥 밑으로
    //          now가 h + 1이면 현재인덱스가 i와 같은지 검사, 맞다면 넘어가고 아니면 breakl
    //          int now = 1;
    //          int r = i;
    //          while(now <= h){
    //              if(!ary[r][now]){
    //                  now++;
    //              }else{
    //                  r = ary[r][now];
    //                  now++;
    //              }
    //          }
    //          if(r != i) {
    //              return false;
    //          }
    //      }
    //      return true;

//3.아니면 선 추가.
선 추가 로직. 원복 생각해야함.
배열 돌면서 0두개 양 옆으로 연속인 부분 vector에 추가해야함.
vector<pair<int, int>> temp;
for(int i = 1; i <= h; i++){
    for(int j = 1; j < n; j++){
        if(ary[i][j] == 0 && ary[i][j + 1] == 0){
            temp.push_back({i, j});
        }
    }
}
이제 temp에서 1개 or 2개 뽑아서 그 부분 채워야함
combi 쓰면됨.

마지막으로 채운 부분 다시 원복


//4.계산, 맞다면 break 하고 출력, 틀렸다면 3번으로.


//시간복잡도 -> 최악의 경우 2개추가까지.
//각 추가당 n*h개. 즉 n*h(체크로직) * (300C1 + 300C2 + 300C3) 
//따라서 300 * (300 + 150 * 299 + 100 * 300 * 150)
= 300 * (300 + 45000 + 4500000)
//대략 천만 조금 넘으니 무식하게 ㄱㄱ
//공간복잡도 -> 배열 300개만 생각하면됨. 충분
시간복잡도 안됨.
